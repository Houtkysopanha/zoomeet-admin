<template>
  <div class="">
    <div class="flex items-center justify-between mb-4">
      <div>
        <h2 class="text-lg font-semibold">Ticket Packages</h2>
        <p class="text-gray-400">Create and manage different ticket types</p>
      </div>
      <div v-if="currentEventId" class="text-right">
        <p class="px-3 py-1 rounded-full text-xs font-medium bg-green-100 text-green-500">Basic Info Saved</p>
        <p class="text-xs text-gray-500">{{ currentEventName }}</p>
        <p v-if="shouldShowEditMode" class="px-3 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-500">Edit Mode</p>
        <p v-else class="text-xs text-purple-600 font-medium">🆕 Create Mode</p>
      </div>
    </div>

    <!-- Event Status Alert -->
    <div v-if="!currentEventId" class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
      <div class="flex items-center">
        <Icon name="heroicons:exclamation-triangle" class="w-5 h-5 text-yellow-600 mr-2" />
        <div>
          <p class="text-sm font-medium text-yellow-800">Basic Info Not Saved</p>
          <p class="text-xs text-yellow-600">Please complete and save the Basic Info tab first.</p>
        </div>
      </div>
    </div>
    
    <!-- Dynamically rendered Ticket Forms -->
    <!-- Edit Mode Warning for Published Events -->
    <div v-if="isEditMode && eventData?.is_published" class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
      <div class="flex items-center">
        <Icon name="heroicons:information-circle" class="w-5 h-5 text-blue-600 mr-2" />
        <div>
          <p class="text-sm font-medium text-blue-800">Editing Published Event</p>
          <p class="text-xs text-blue-600">Changes to tickets will affect live event. Please review carefully before saving.</p>
        </div>
      </div>
    </div>

    <TransitionGroup name="ticket-list" tag="div">
      <TicketForm
        v-for="(ticket, index) in tickets"
        :key="ticket.id"
        v-model="tickets[index]"
        :ticket-index="index"
        :readonly="false"
      />
    </TransitionGroup>

    <!-- Action Buttons -->
    <div class="flex justify-center items-center mt-6">
      <Button
        @click="addTicket"
        class="add-ticket-btn"
        :disabled="!currentEventId"
      >
        <Icon name="heroicons:plus" class="mr-2" />
        Add Ticket Package
      </Button>
      
      <!-- Note: All save and update actions are handled by the main page buttons -->
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, inject } from "vue"
import Button from "primevue/button"
import TicketForm from '~/components/common/TicketForm.vue'
import LoadingSpinner from '~/components/ui/LoadingSpinner.vue'
import { createTicketTypes, updateTicketType, getEventDetails, getEventTicketTypes } from '@/composables/api'
import { useToast } from "primevue/usetoast"
import { useEventStore } from '~/composables/useEventStore'
import { useEventTabsStore } from '~/composables/useEventTabs'

const loading = ref(false)
const toast = useToast()

// Event data
const currentEventId = ref(null)
const currentEventName = ref('')
const tickets = ref([])
const isEditMode = ref(false)
const eventData = ref(null)

// Track if there are new tickets added
const hasNewTickets = computed(() => {
  return tickets.value.some(ticket => !ticket.ticket_type_id)
})

// Track if there are existing tickets being updated
const hasExistingTickets = computed(() => {
  return tickets.value.some(ticket => ticket.ticket_type_id)
})

// Track completion state like Basic Info
const hasCompletedFirstDraft = ref(false)

// Determine if this is first draft or save changes mode
const isFirstDraft = computed(() => {
  return !hasCompletedFirstDraft.value && !hasExistingTickets.value
})

// Determine button text like Basic Info
const getTicketButtonText = computed(() => {
  if (isFirstDraft.value) {
    return 'Save Draft'
  } else {
    return 'Save Changes'
  }
})

// Enhanced computed property to determine if we should show edit mode UI
const shouldShowEditMode = computed(() => {
  return isEditMode.value && hasExistingTickets.value
})

// Validate ticket data
const isValidTicketData = computed(() => {
  if (tickets.value.length === 0) return false
  
  return tickets.value.every(ticket => {
    const name = (ticket.name || '').toString().trim()
    const description = (ticket.description || ticket.tag || '').toString().trim()
    const price = ticket.price !== null && ticket.price !== undefined ? parseFloat(ticket.price) : NaN
    const quantity = ticket.quantity !== null && ticket.quantity !== undefined ? parseInt(ticket.quantity) : NaN
    
    return name.length > 0 &&
           description.length > 0 &&
           !isNaN(price) && price >= 0 &&
           !isNaN(quantity) && quantity > 0
  })
})

// Clear all ticket data and refresh from API with proper event isolation
const clearAndRefreshTickets = async () => {
  if (!currentEventId.value) return

  loading.value = true
  try {
    // Clear local state completely
    tickets.value = []
    hasExistingTickets.value = false
    
    // Clear tab store data for current event only
    const tabsStore = useEventTabsStore()
    tabsStore.clearTabData(2) // Clear tickets tab data
    
    // Clear event store tickets for current event
    const eventStore = useEventStore()
    if (eventStore.currentEvent && eventStore.currentEvent.id === currentEventId.value) {
      eventStore.currentEvent.ticket_types = []
    }
    
    // Force reload from API with event ID validation
    if (currentEventId.value) {
      await loadExistingTickets()
    }
  } catch (error) {
    toast.add({
      severity: 'error',
      summary: 'Refresh Failed',
      detail: 'Failed to refresh ticket data',
      life: 3000
    })
  } finally {
    loading.value = false
  }
}

// Load existing tickets if available
const loadTickets = async () => {
  if (!currentEventId.value) return

  loading.value = true
  try {
    const response = await getEventDetails(currentEventId.value)
    if (response?.data?.ticket_types?.length > 0) {
      tickets.value = response.data.ticket_types.map(ticket => ({
        id: Date.now() + Math.random(),
        ticket_type_id: ticket.id,
        name: ticket.name,
        price: ticket.price,
        quantity: ticket.total,
        description: ticket.tag || '',
        sort_order: ticket.sort_order,
        is_active: ticket.is_active
      }))
      hasExistingTickets.value = true
      toast.add({
        severity: 'success',
        summary: 'Tickets Loaded',
        detail: `Loaded ${tickets.value.length} existing tickets`,
        life: 3000
      })
    }
  } catch (error) {
    toast.add({
      severity: 'error',
      summary: 'Load Failed',
      detail: 'Failed to load existing tickets',
      life: 3000
    })
  } finally {
    loading.value = false
  }
}

const createNewTicket = () => {
  const ticketNumber = tickets.value.length + 1
  const newTicket = {
    id: Date.now() + Math.random(),
    ticket_type_id: null,
    name: '', // Initialize as empty string
    price: 0, // Initialize as number
    quantity: 1, // Initialize as number
    description: '', // Initialize as empty string
    tag: '', // Initialize as empty string for API compatibility
    sort_order: ticketNumber,
    is_active: true,
    isValidating: false
  }
  
  return newTicket
}

const addTicket = () => {
  if (!currentEventId.value) {
    toast.add({
      severity: 'warn',
      summary: 'Basic Info Required',
      detail: 'Please complete and save Basic Info first.',
      life: 3000
    })
    return
  }
  tickets.value.push(createNewTicket())
}

// Enhanced save current tab data for tab switching with event validation
const handleSaveCurrentTab = (event) => {
  const tabsStore = useEventTabsStore()
  
  // Validate event context if provided
  if (event?.detail?.eventId && event.detail.eventId !== currentEventId.value) {
    return
  }
  
  // Only save if we have a valid event ID
  if (!currentEventId.value) {
    return
  }
  
  // Save current ticket data to tab persistence without API call - PRESERVE ticket_type_id
  const tabData = {
    ticketTypes: tickets.value.map(ticket => {
      const savedTicket = {
        id: ticket.id,
        ticket_type_id: ticket.ticket_type_id, // CRITICAL: Must preserve for updates
        name: ticket.name || '',
        description: ticket.description || ticket.tag || '',
        tag: ticket.tag || ticket.description || '',
        price: ticket.price || 0,
        quantity: ticket.quantity || 1,
        sort_order: ticket.sort_order,
        is_active: ticket.is_active,
        eventId: currentEventId.value // Ensure event ID is included
      }
      
      // Debug log to ensure ticket_type_id is preserved
      if (ticket.ticket_type_id) {
        console.log(`💾 Saving ticket "${ticket.name}" with ticket_type_id: ${ticket.ticket_type_id}`)
      } else {
        console.log(`💾 Saving new ticket "${ticket.name}" without ticket_type_id (will be created)`)
      }
      
      return savedTicket
    }),
    lastSaved: new Date().toISOString(),
    hasTickets: tickets.value.length > 0,
    eventId: currentEventId.value,
    isEditMode: isEditMode.value,
    hasCompletedFirstDraft: hasCompletedFirstDraft.value, // Preserve completion state
    isComplete: tickets.value.length > 0 && tickets.value.every(t =>
      (t.name && t.name.trim()) &&
      (t.description && t.description.trim()) &&
      (t.price !== null && t.price !== undefined && t.price >= 0) &&
      (t.quantity !== null && t.quantity !== undefined && t.quantity > 0)
    )
  }
  
  tabsStore.saveTabData(2, tabData)
}

// Save Draft - for new tickets or adding more tickets
const saveDraft = async () => {
  await saveTicketsInternal('draft')
}

// Update Tickets - for editing existing tickets
const updateTickets = async () => {
  await saveTicketsInternal('update')
}


// Internal save method - ENHANCED FOR NEW FLOW with edit/create mode validation
const saveTicketsInternal = async (mode = 'draft') => {
  const eventStore = useEventStore()
  const tabsStore = useEventTabsStore()

  if (!currentEventId.value) {
    toast.add({
      severity: 'error',
      summary: 'No Event',
      detail: 'Please complete and save Basic Info first.',
      life: 3000
    })
    return
  }

  if (tickets.value.length === 0) {
    toast.add({
      severity: 'warn',
      summary: 'No Tickets',
      detail: 'Please add at least one ticket package.',
      life: 3000
    })
    return
  }

  // Show different confirmation for published events
  if (isEditMode.value && eventData.value?.is_published) {
    toast.add({
      severity: 'info',
      summary: 'Updating Published Event',
      detail: 'You are modifying tickets for a live event. Changes will be visible to users immediately.',
      life: 4000
    })
  }

  // Enhanced ticket validation with better error detection
  const invalidTickets = []
  
  for (let index = 0; index < tickets.value.length; index++) {
    const ticket = tickets.value[index]
    const ticketNumber = index + 1
    const errors = []
    
    // Get current values with fallbacks
    const name = (ticket.name || '').toString().trim()
    const description = (ticket.description || ticket.tag || '').toString().trim()
    const price = ticket.price !== null && ticket.price !== undefined ? parseFloat(ticket.price) : NaN
    const quantity = ticket.quantity !== null && ticket.quantity !== undefined ? parseInt(ticket.quantity) : NaN
    
    // Validate name - must be non-empty string
    if (!name || name.length === 0) {
      errors.push('name')
    }
    
    // Validate description - must be non-empty string
    if (!description || description.length === 0) {
      errors.push('description')
    }
    
    // Validate price - must be valid number >= 0
    if (isNaN(price) || price < 0) {
      errors.push('price')
    }
    
    // Validate quantity - must be valid integer >= 1
    if (isNaN(quantity) || quantity < 1) {
      errors.push('quantity')
    }
    
    // Mark ticket for validation display if errors exist
    if (errors.length > 0) {
      ticket.isValidating = true
      invalidTickets.push({
        ticketNumber,
        ticketName: name || `Ticket ${ticketNumber}`,
        errors
      })
    } else {
      ticket.isValidating = false
    }
  }

  if (invalidTickets.length > 0) {
    const errorMessages = invalidTickets.map(ticket => {
      const fieldNames = {
        name: 'Ticket Name',
        description: 'Description',
        price: 'Price',
        quantity: 'Quantity'
      }
      const readableErrors = ticket.errors.map(error => fieldNames[error] || error)
      return `• ${ticket.ticketName || `Ticket ${ticket.ticketNumber}`}: ${readableErrors.join(', ')}`
    })

    // Show only one toast notification
    toast.add({
      severity: 'error',
      summary: 'Validation Error',
      detail: 'Please complete all required fields for all tickets before saving.',
      life: 5000
    })

    // Force re-render of validation states
    tickets.value = [...tickets.value.map((ticket, index) => ({
      ...ticket,
      isValidating: invalidTickets.some(invalid => invalid.ticketNumber === index + 1)
    }))]

    return
  }

  loading.value = true

  try {
    // Get existing tickets from API to determine update vs create strategy
    let existingTickets = []
    try {
      console.log('🔍 Fetching existing tickets from API for event:', currentEventId.value)
      const existingTicketsResponse = await getEventTicketTypes(currentEventId.value)
      
      // Handle different response structures
      if (existingTicketsResponse?.data && Array.isArray(existingTicketsResponse.data)) {
        existingTickets = existingTicketsResponse.data
      } else if (Array.isArray(existingTicketsResponse)) {
        existingTickets = existingTicketsResponse
      } else {
        existingTickets = []
      }
      
      console.log('📋 Found existing tickets in API:', existingTickets.map(t => ({ id: t.id, name: t.name })))
    } catch (error) {
      console.warn('⚠️ Failed to fetch existing tickets from API:', error)
      existingTickets = []
    }

    // Ensure existingTickets is always an array
    if (!Array.isArray(existingTickets)) {
      existingTickets = []
    }

    console.log('🎫 Current local tickets to process:', tickets.value.map(t => ({
      id: t.id,
      ticket_type_id: t.ticket_type_id,
      name: t.name,
      hasApiId: !!t.ticket_type_id
    })))

    const ticketUpdates = []
    const updatePromises = []
    
    // Process each ticket individually
    for (let index = 0; index < tickets.value.length; index++) {
      const ticket = tickets.value[index]
      const ticketNumber = index + 1
      
      const name = String(ticket.name || '').trim()
      const description = String(ticket.description || ticket.tag || '').trim()
      const price = parseFloat(ticket.price || 0)
      const quantity = parseInt(ticket.quantity || 0)


      // Enhanced validation
      const errors = []
      if (!name) errors.push(`Ticket ${ticketNumber}: Name is required`)
      if (!description) errors.push(`Ticket ${ticketNumber}: Description is required`)
      if (isNaN(price) || price < 0) errors.push(`Ticket ${ticketNumber}: Price must be 0 or greater`)
      if (isNaN(quantity) || quantity < 1) errors.push(`Ticket ${ticketNumber}: Quantity must be at least 1`)

      if (errors.length > 0) {
        throw new Error(errors.join('\n'))
      }

      // Enhanced ticket matching logic with debugging
      console.log(`🔍 Processing ticket ${ticketNumber}:`, {
        ticketId: ticket.id,
        ticketTypeId: ticket.ticket_type_id,
        name: name,
        hasTicketTypeId: !!ticket.ticket_type_id
      })
      
      // Check if this ticket exists in API (by ID first, then by name)
      const existingTicket = existingTickets.find(et => {
        const match = et.id === ticket.ticket_type_id
        console.log(`🔍 Checking existing ticket ${et.id} vs ${ticket.ticket_type_id}:`, match)
        return match
      })
      
      console.log(`🔍 Existing ticket found for "${name}":`, !!existingTicket, existingTicket?.id)
      
      const ticketData = {
        name: name,
        price: parseFloat(price),
        total: quantity,
        tag: description,
        sort_order: index + 1,
        is_active: 1
      }

      // Determine if this should be an update or create operation
      const shouldUpdate = existingTicket && ticket.ticket_type_id
      const shouldCreate = !ticket.ticket_type_id || !existingTicket

      console.log(`🎯 Operation decision for "${name}":`, {
        shouldUpdate,
        shouldCreate,
        hasTicketTypeId: !!ticket.ticket_type_id,
        hasExistingTicket: !!existingTicket
      })

      if (shouldUpdate) {
        // UPDATE existing ticket using PUT method
        console.log(`🔄 UPDATING ticket "${name}" with ID ${existingTicket.id}`)
        const updatePromise = updateTicketType(currentEventId.value, existingTicket.id, ticketData)
          .then(() => {
            console.log(`✅ Successfully updated ticket "${name}"`)
            ticketUpdates.push(`Updated: ${name}`)
            // Ensure local ticket maintains the API ID
            ticket.ticket_type_id = existingTicket.id
          })
          .catch((error) => {
            console.error(`❌ Failed to update ticket "${name}":`, error)
            ticketUpdates.push(`Failed to update: ${name}`)
            throw error
          })
        
        updatePromises.push(updatePromise)
      } else if (shouldCreate) {
        // CREATE new ticket using POST method
        console.log(`🆕 CREATING new ticket "${name}"`)
        const createPromise = createTicketTypes(currentEventId.value, [ticketData])
          .then((response) => {
            console.log(`✅ Successfully created ticket "${name}"`)
            ticketUpdates.push(`Created: ${name}`)
            // Update local ticket with the new API ID if available
            if (response?.data?.[0]?.id) {
              ticket.ticket_type_id = response.data[0].id
              console.log(`🔗 Assigned new ID ${response.data[0].id} to ticket "${name}"`)
            }
          })
          .catch((error) => {
            console.error(`❌ Failed to create ticket "${name}":`, error)
            ticketUpdates.push(`Failed to create: ${name}`)
            throw error
          })
        
        updatePromises.push(createPromise)
      } else {
        console.log(`⚠️ No operation needed for ticket "${name}" - skipping`)
      }
    }

    // Wait for all operations to complete
    console.log(`⏳ Waiting for ${updatePromises.length} ticket operations to complete...`)
    await Promise.all(updatePromises)
    console.log(`✅ All ticket operations completed`)

      // Log the results for debugging
      console.log('🎫 Ticket operation results:', ticketUpdates)

      // Update stores with new ticket data
      
      // Update event store
      if (eventStore.currentEvent) {
        const updatedTickets = tickets.value.map(ticket => ({
          id: ticket.ticket_type_id || ticket.id,
          name: ticket.name,
          price: parseFloat(ticket.price) || 0,
          total: parseInt(ticket.quantity) || 0,
          tag: ticket.description || '',
          sort_order: ticket.sort_order,
          is_active: ticket.is_active ? 1 : 0
        }))
        eventStore.currentEvent.ticket_types = updatedTickets
      }

      // Update tab store and mark as complete - PRESERVE ticket_type_id
      const tabData = {
        ticketTypes: tickets.value.map(ticket => ({
          id: ticket.id,
          ticket_type_id: ticket.ticket_type_id, // CRITICAL: Preserve for future updates
          name: ticket.name || '',
          description: ticket.description || ticket.tag || '',
          tag: ticket.tag || ticket.description || '',
          price: ticket.price || 0,
          quantity: ticket.quantity || 1,
          sort_order: ticket.sort_order,
          is_active: ticket.is_active,
          eventId: currentEventId.value
        })),
        lastSaved: new Date().toISOString(),
        hasTickets: true,
        eventId: currentEventId.value,
        hasCompletedFirstDraft: hasCompletedFirstDraft.value, // Preserve completion state
        isComplete: true,
        validTickets: tickets.value.length > 0
      }
      
      // Debug log to ensure ticket_type_id is preserved after save
      tickets.value.forEach((ticket, index) => {
        console.log(`💾 After save - Ticket "${ticket.name}" ticket_type_id: ${ticket.ticket_type_id}`)
      })
      
      tabsStore.markTabComplete(2)
      tabsStore.markTabSaved(2)
      tabsStore.saveTabData(2, tabData)

      // Show detailed success message with counts - Enhanced like Basic Info
      const updateCount = ticketUpdates.filter(update => update.includes('Updated:')).length
      const createCount = ticketUpdates.filter(update => update.includes('Created:')).length
      const failedCount = ticketUpdates.filter(update => update.includes('Failed')).length
      
      console.log('📊 Operation counts:', { updateCount, createCount, failedCount, total: ticketUpdates.length })
      
      let summaryMessage = 'Tickets Saved Successfully! 🎫'
      let detailMessage = ''
      
      if (updateCount > 0 && createCount > 0) {
        // Mixed operation - like Basic Info after first draft
        summaryMessage = 'Tickets have changed and created more! 🎫'
        detailMessage = `Successfully updated ${updateCount} existing ticket(s) and created ${createCount} new ticket(s). Your event now has ${tickets.value.length} total tickets.`
      } else if (updateCount > 0) {
        // Only updates - like Basic Info save changes
        summaryMessage = 'Success for change ticket! 🎫'
        detailMessage = `Successfully updated ${updateCount} existing ticket(s)`
      } else if (createCount > 0) {
        // Only creates - like Basic Info first draft
        if (isFirstDraft.value) {
          summaryMessage = 'Tickets Created! 🎫'
          detailMessage = `Successfully created ${createCount} ticket(s). You can now add more tickets or edit existing ones.`
        } else {
          summaryMessage = `Created ${createCount} additional ticket${createCount > 1 ? 's' : ''}! 🎫`
          detailMessage = `Successfully created ${createCount} new ticket(s)`
        }
      } else if (ticketUpdates.length > 0) {
        // Some operations occurred but no clear success messages
        summaryMessage = 'Tickets Processed! 🎫'
        detailMessage = 'All ticket operations completed successfully'
      } else {
        // Fallback message
        summaryMessage = 'Tickets Saved! 🎫'
        detailMessage = 'All tickets processed successfully'
      }
      
      console.log('🎉 Showing success message:', { summaryMessage, detailMessage })
      
      toast.add({
        severity: 'success',
        summary: summaryMessage,
        detail: detailMessage,
        life: 5000
      })
      
      // Mark as completed after first successful save (like Basic Info)
      if (isFirstDraft.value) {
        hasCompletedFirstDraft.value = true
        
        // Save completion state to tab store for main page button
        const tabsStore = useEventTabsStore()
        const currentTabData = tabsStore.getTabData(2)
        tabsStore.saveTabData(2, {
          ...currentTabData,
          hasCompletedFirstDraft: true,
          firstDraftCompletedAt: new Date().toISOString()
        })
        
        console.log('🎫 First draft completed, switching to "Save Changes" mode')
      }
      
      // Mark ticket tab as completed in parent
      const eventCreationState = inject('eventCreationState')
      if (eventCreationState?.markTabCompleted) {
        eventCreationState.markTabCompleted(2)
      }

    // Reload tickets to get updated data with fresh IDs
    setTimeout(async () => {
      await loadExistingTickets()
    }, 1000) // Small delay to ensure server has processed the changes

  } catch (error) {
    
    let errorMessage = 'Failed to save tickets. Please try again.'
    let errorSummary = 'Save Failed'
    
    if (error.message) {
      errorMessage = error.message
      
      if (error.message.includes('Authentication')) {
        errorSummary = 'Authentication Error'
        errorMessage = 'Please login again to continue.'
      } else if (error.message.includes('Validation')) {
        errorSummary = 'Validation Error'
      } else if (error.message.includes('Event not found')) {
        errorSummary = 'Event Not Found'
        errorMessage = 'The event could not be found. Please refresh and try again.'
      }
    }
    
    toast.add({
      severity: 'error',
      summary: errorSummary,
      detail: errorMessage,
      life: 5000
    })
  } finally {
    loading.value = false
  }
}

// Load existing tickets when in edit mode with proper event validation
const loadExistingTickets = async () => {
  if (!currentEventId.value) {
    return
  }

  // Validate that we're loading tickets for the correct event
  const eventStore = useEventStore()
  if (eventStore.currentEvent && eventStore.currentEvent.id !== currentEventId.value) {
    tickets.value = []
    hasExistingTickets.value = false
    return
  }

  loading.value = true
  try {
    console.log('🎫 Loading existing tickets for event:', currentEventId.value)
    const response = await getEventTicketTypes(currentEventId.value)
    
    if (response && response.data && Array.isArray(response.data)) {
      const existingTickets = response.data
      
      if (existingTickets.length > 0) {
        console.log('✅ Found existing tickets:', existingTickets.length)
        
        // Clear current tickets and load existing ones with proper validation
        tickets.value = existingTickets.map((ticket, index) => {
          const loadedTicket = {
            id: ticket.id || Date.now() + Math.random() + index,
            ticket_type_id: ticket.id, // Store original ID for updates - CRITICAL for update detection
            name: ticket.name || '',
            description: ticket.description || ticket.tag || '',
            tag: ticket.tag || ticket.description || '', // Ensure both fields
            price: parseFloat(ticket.price) || 0,
            quantity: parseInt(ticket.total || ticket.quantity) || 1,
            sort_order: ticket.sort_order || (index + 1),
            is_active: ticket.is_active === undefined ? true : Boolean(ticket.is_active),
            isValidating: false,
            eventId: currentEventId.value // Add event ID for validation
          }
          
          console.log('📝 Loaded ticket from API for updates:', {
            index,
            eventId: currentEventId.value,
            apiId: ticket.id,
            ticketTypeId: loadedTicket.ticket_type_id,
            name: loadedTicket.name,
            canUpdate: !!loadedTicket.ticket_type_id
          })
          
          return loadedTicket
        })
        
        // Mark that we have existing tickets that can be updated
        hasCompletedFirstDraft.value = true
        console.log('🎫 Existing tickets loaded - marking first draft as completed for "Save Changes" mode')
        
        hasExistingTickets.value = true
        isEditMode.value = true
        
        console.log('📝 Loaded tickets for event:', {
          eventId: currentEventId.value,
          ticketCount: tickets.value.length,
          isEditMode: isEditMode.value
        })
        
        toast.add({
          severity: 'success',
          summary: 'Tickets Loaded',
          detail: `Loaded ${existingTickets.length} existing ticket(s) for editing`,
          life: 3000
        })
      } else {
        console.log('📝 No existing tickets found, starting fresh')
        hasExistingTickets.value = false
        tickets.value = [] // Clear any existing tickets
        isEditMode.value = false
      }
    }
  } catch (error) {
    console.error('❌ Failed to load existing tickets:', error)
    toast.add({
      severity: 'error',
      summary: 'Load Failed',
      detail: error.message || 'Could not load existing tickets. You can create new ones.',
      life: 4000
    })
    tickets.value = [] // Reset on error
    hasExistingTickets.value = false
    isEditMode.value = false
  } finally {
    loading.value = false
  }
}

// Watch tickets array for changes
watch(tickets, (newTickets) => {
  if (currentEventId.value) {
    console.log('🎫 Tickets changed, saving to tab store:', newTickets.length)
    const tabsStore = useEventTabsStore()
    
    // Save current ticket data immediately - PRESERVE ticket_type_id
    const tabData = {
      ticketTypes: newTickets.map(ticket => ({
        id: ticket.id,
        ticket_type_id: ticket.ticket_type_id, // CRITICAL: Preserve for updates
        name: ticket.name || '',
        description: ticket.description || ticket.tag || '',
        tag: ticket.tag || ticket.description || '',
        price: ticket.price || 0,
        quantity: ticket.quantity || 1,
        sort_order: ticket.sort_order,
        is_active: ticket.is_active,
        eventId: currentEventId.value
      })),
      lastSaved: new Date().toISOString(),
      hasTickets: newTickets.length > 0,
      eventId: currentEventId.value,
      hasCompletedFirstDraft: hasCompletedFirstDraft.value, // Preserve completion state
      isComplete: newTickets.length > 0 && newTickets.every(t =>
        (t.name && t.name.trim()) &&
        (t.description && t.description.trim()) &&
        (t.price !== null && t.price !== undefined && t.price >= 0) &&
        (t.quantity !== null && t.quantity !== undefined && t.quantity > 0)
      ),
      hasUnsavedChanges: true
    }
    
    // Debug log to track ticket_type_id preservation
    newTickets.forEach((ticket, index) => {
      if (ticket.ticket_type_id) {
        console.log(`🔗 Watch: Ticket "${ticket.name}" has ticket_type_id: ${ticket.ticket_type_id}`)
      } else {
        console.log(`🆕 Watch: Ticket "${ticket.name}" is new (no ticket_type_id)`)
      }
    })
    
    tabsStore.saveTabData(2, tabData)
    tabsStore.markTabModified(2)
  }
}, { deep: true })

// Enhanced initialization with better data restoration
onMounted(async () => {
  console.log('🎫 Initializing TicketPacket component...')
  
  // Use Pinia store instead of localStorage
  const eventStore = useEventStore()
  const tabsStore = useEventTabsStore()
  
  if (eventStore.hasCurrentEvent) {
    currentEventId.value = eventStore.currentEvent.id
    currentEventName.value = eventStore.currentEvent.name || "Unnamed Event"
    eventData.value = eventStore.currentEvent
    // Enhanced edit mode detection - if event has an ID, it's in edit mode
    isEditMode.value = !!eventStore.currentEvent.id
    
    console.log('📋 Current event found:', {
      id: currentEventId.value,
      name: currentEventName.value,
      isEditMode: isEditMode.value,
      status: eventStore.currentEvent.status,
      isPublished: eventStore.currentEvent.is_published
    })
    
    // Check if event has completed basic info from tab store
    const basicInfoData = tabsStore.getTabData(0)
    const hasBasicInfo = basicInfoData.isComplete || (
      eventStore.currentEvent &&
      eventStore.currentEvent.name &&
      eventStore.currentEvent.category_id &&
      eventStore.currentEvent.start_date &&
      eventStore.currentEvent.end_date &&
      eventStore.currentEvent.location
    )
    
    if (!hasBasicInfo) {
      console.log("⚠️ Basic info not complete.")
      toast.add({
        severity: 'warn',
        summary: 'Basic Info Required',
        detail: 'Please complete and save Basic Info first.',
        life: 3000
      })
      return
    }
    
    console.log("📋 Loading event for tickets:", {
      id: currentEventId.value,
      name: currentEventName.value,
      hasBasicInfo,
      isTabComplete: tabsStore.isTabCompleted(0)
    })

    // Enhanced ticket restoration with priority order
    const ticketTabData = tabsStore.getTabData(2)
    let ticketsRestored = false
    
    // Check if first draft was already completed (restore completion state)
    if (ticketTabData.hasCompletedFirstDraft) {
      hasCompletedFirstDraft.value = true
      console.log('🎫 Restored first draft completion state - button will show "Save Changes"')
    }
    
    // Priority 1: Tab persistence (user's current work)
    if (ticketTabData.ticketTypes && ticketTabData.ticketTypes.length > 0) {
      tickets.value = ticketTabData.ticketTypes.map((ticket, index) => {
        const restoredTicket = {
          id: ticket.id || Date.now() + Math.random() + index,
          ticket_type_id: ticket.ticket_type_id || ticket.id, // CRITICAL: Preserve ticket_type_id for updates
          name: ticket.name || '',
          description: ticket.description || ticket.tag || '',
          tag: ticket.tag || ticket.description || '', // Ensure both fields
          price: parseFloat(ticket.price) || 0,
          quantity: parseInt(ticket.quantity || ticket.total) || 1,
          sort_order: ticket.sort_order || (index + 1),
          is_active: ticket.is_active === undefined ? true : Boolean(ticket.is_active),
          isValidating: false
        }
        
        console.log('🔄 Restored ticket from tab persistence:', {
          index,
          ticketTypeId: restoredTicket.ticket_type_id,
          name: restoredTicket.name,
          canUpdate: !!restoredTicket.ticket_type_id
        })
        
        return restoredTicket
      })
      hasExistingTickets.value = true
      ticketsRestored = true
      tabsStore.markTabComplete(2)
      
      // If we have tickets with ticket_type_id, mark first draft as completed
      const hasTicketsWithIds = tickets.value.some(t => t.ticket_type_id)
      if (hasTicketsWithIds) {
        hasCompletedFirstDraft.value = true
        console.log('🎫 Restored tickets with IDs - marking first draft as completed')
      }
    }
    // Priority 2: Event store (loaded from API)
    else if (eventStore.currentEvent.ticket_types?.length > 0) {
      tickets.value = eventStore.currentEvent.ticket_types.map((ticket, index) => {
        const restoredTicket = {
          id: ticket.id || Date.now() + Math.random() + index,
          ticket_type_id: ticket.id, // CRITICAL: Store API ID for updates
          name: ticket.name || '',
          description: ticket.description || ticket.tag || '',
          tag: ticket.tag || ticket.description || '', // Ensure both fields
          price: parseFloat(ticket.price) || 0,
          quantity: parseInt(ticket.total || ticket.quantity) || 1,
          sort_order: ticket.sort_order || (index + 1),
          is_active: ticket.is_active === undefined ? true : Boolean(ticket.is_active),
          isValidating: false
        }
        
        console.log('🏪 Restored ticket from event store:', {
          index,
          apiId: ticket.id,
          ticketTypeId: restoredTicket.ticket_type_id,
          name: restoredTicket.name,
          canUpdate: !!restoredTicket.ticket_type_id
        })
        
        return restoredTicket
      })
      hasExistingTickets.value = true
      ticketsRestored = true
      
      // Mark first draft as completed since these are existing tickets
      hasCompletedFirstDraft.value = true
      console.log('🎫 Event store tickets loaded - marking first draft as completed')
      
      // Save to tab persistence for future use
      handleSaveCurrentTab()
      tabsStore.markTabComplete(2)
    }
    
    // Priority 3: Load fresh from API if nothing in stores
    if (!ticketsRestored) {
      await loadExistingTickets()
    }
    
    // Auto-save current state for tab switching
    if (tickets.value.length > 0) {
      handleSaveCurrentTab()
    }
    
  } else {
    toast.add({
      severity: 'warn',
      summary: 'Event Required',
      detail: 'Please complete and save Basic Info first.',
      life: 3000
    })
  }

  // Add event listeners for ticket saving and tab switching with event validation
  window.addEventListener('saveTickets', saveDraft)
  window.addEventListener('saveCurrentTab', handleSaveCurrentTab)
  window.addEventListener('loadTicketData', (event) => {
    // Only load if the event ID matches current event
    if (event.detail?.eventId === currentEventId.value) {
      loadExistingTickets()
    }
  })
  
  // Listen for edit mode changes from main page
  window.addEventListener('editModeChanged', (event) => {
    if (event.detail?.eventId === currentEventId.value) {
      isEditMode.value = event.detail.isEditMode
      if (event.detail.eventData) {
        eventData.value = event.detail.eventData
      }
    }
  })
  
  // Add event listener for event switching to clear data
  window.addEventListener('clearTicketData', (event) => {
    if (event.detail?.eventId !== currentEventId.value) {
      tickets.value = []
      hasExistingTickets.value = false
      isEditMode.value = false
      
      // Clear tab store data
      const tabsStore = useEventTabsStore()
      tabsStore.clearTabData(2, event.detail?.eventId)
    }
  })
})

// Remove event listeners when component unmounts
onUnmounted(() => {
  window.removeEventListener('saveTickets', saveDraft)
  window.removeEventListener('saveCurrentTab', handleSaveCurrentTab)
  // Note: loadTicketData and clearTicketData use anonymous functions, so they can't be removed individually
  // This is acceptable as the component is being destroyed anyway
})
</script>

<style scoped>
.add-ticket-btn {
  @apply bg-gradient-to-r from-purple-600 to-indigo-600 text-white;
  @apply hover:from-purple-700 hover:to-indigo-700;
  @apply px-6 py-3 rounded-full font-medium shadow-lg hover:shadow-xl;
  @apply transition-all duration-300 ease-in-out border-0;
}

.add-ticket-btn:hover {
  transform: translateY(-2px);
}

.save-draft-btn {
  @apply bg-gradient-to-r from-purple-600 to-indigo-600 text-white;
  @apply hover:from-purple-700 hover:to-indigo-700;
  @apply px-6 py-3 rounded-full font-medium shadow-lg hover:shadow-xl;
  @apply transition-all duration-300 ease-in-out border-0;
}

.save-draft-btn:hover {
  transform: translateY(-2px);
}

.save-draft-btn:disabled {
  @apply bg-gray-400 cursor-not-allowed;
  transform: none;
}

.update-tickets-btn {
  @apply bg-gradient-to-r from-green-600 to-emerald-600 text-white;
  @apply hover:from-green-700 hover:to-emerald-700;
  @apply px-6 py-3 rounded-full font-medium shadow-lg hover:shadow-xl;
  @apply transition-all duration-300 ease-in-out border-0;
}

.update-tickets-btn:hover {
  transform: translateY(-2px);
}

.update-tickets-btn:disabled {
  @apply bg-gray-400 cursor-not-allowed;
  transform: none;
}

/* Transition for adding/removing tickets */
.ticket-list-enter-active,
.ticket-list-leave-active {
  transition: all 0.5s ease;
}
.ticket-list-enter-from,
.ticket-list-leave-to {
  opacity: 0;
  transform: translateY(30px);
}
.ticket-list-leave-active {
  position: absolute;
  width: 100%;
}
</style>
